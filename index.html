<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="stylesheet" href="style.css">
  <title>Technical Document</title>
</head>
<body>
  <nav id="navbar">
    <header>Git Commands</header>
    <ul>
      <li><a class="nav-link" href="#git_add">git add</a></li>
      <li><a class="nav-link" href="#git_branch">git branch</a></li>
      <li><a class="nav-link" href="#git_checkout">git checkout</a></li>
      <li><a class="nav-link" href="#git_clean">git clean</a></li>
      <li><a class="nav-link" href="#git_clone">git clone</a></li>
      <li><a class="nav-link" href="#git_commit">git commit</a></li>
      <li><a class="nav-link" href="#git_commit_--amend">git commit --amend</a></li>
      <li><a class="nav-link" href="#git_config">git config</a></li>
      <li><a class="nav-link" href="#git_fetch">git fetch</a></li>
      <li><a class="nav-link" href="#git_init">git init</a></li>
      <li><a class="nav-link" href="#git_log">git log</a></li>
      <li><a class="nav-link" href="#git_merge">git merge</a></li>
      <li><a class="nav-link" href="#git_pull">git pull</a></li>
      <li><a class="nav-link" href="#git_push">git push</a></li>
      <li><a class="nav-link" href="#git_rebase">git rebase</a></li>
      <li><a class="nav-link" href="#git_rebase_-i">git rebase -i</a></li>
      <li><a class="nav-link" href="#git_reflog">git reflog</a></li>
      <li><a class="nav-link" href="#git_remote">git remote</a></li>
      <li><a class="nav-link" href="#git_reset">git reset</a></li>
      <li><a class="nav-link" href="#git_revert">git revert</a></li>
      <li><a class="nav-link" href="#git_status">git status</a></li>
    </ul>
  </nav>
  <main id="main-doc">
    <section id="git_add" class="main-section">
      <header>git add</header>
      <p>Moves changes from the working directory to the staging area. This gives you the opportunity to prepare a
        snapshot before committing
        it to the official history.</p>
      <p>The <code>git add</code> command adds a change in the working directory to the staging area. It tells Git that
        you want to include updates to
        a particular file in the next commit. However, <code>git add</code> doesn't really affect the repository in any
        significant way—changes are
        not actually recorded until you run <code>git commit</code>.</p>
      <p>In conjunction with these commands, you'll also need git status to view the state of the working directory and
        the staging area.</p>
      <p>To create an initial commit of the current directory, use the following two commands:</p>
      <code class="codeBlock">git add .<br />
        git commit</code>
      <p>Once you’ve got your project up-and-running, new files can be added by passing the path to git add:</p>
      <code class="codeBlock">git add hello.py<br />
        git commit</code>
    </section>
    <section id="git_branch" class="main-section">
      <header>git branch</header>
      <p>This command is your general-purpose branch administration tool. It lets you create isolated development
        environments within a
        single repository.</p>
      <p>A branch represents an independent line of development. Branches serve as an abstraction for the
        edit/stage/commit process.
        You can think of them as a way to request a brand new working directory, staging area, and project history. New
        commits are
        recorded in the history for the current branch, which results in a fork in the history of the project.</p>
      <p>The <code>git branch</code> command lets you create, list, rename, and delete branches. It doesn’t let you
        switch between
        branches or put a forked history back together again. For this reason, <code>git branch</code> is tightly
        integrated with
        the <code>git checkout</code> and <code>git merge</code> commands.</p>
      <p>Common Options:</p>
      <ul>
        <li>List all of the branches in your repository. This is synonymous with <code>git branch --list</code>.
          <code class="codeBlock">git branch</code></li>
        <li>Create a new branch called &lt;branch&gt;. This does not check out the new branch.
          <code class="codeBlock">git branch &lt;branch&gt;</code></li>
        <li>Delete the specified branch. This is a “safe” operation in that Git prevents you from deleting the branch
          if it
          has unmerged changes.<code class="codeBlock">git branch -d &lt;branch&gt;</code></li>
        <li>Force delete the specified branch, even if it has unmerged changes. This is the command to use if you want
          to permanently
          throw away all of the commits associated with a particular line of development.
          <code class="codeBlock">git branch -D &lt;branch&gt;</code></li>
        <li>Rename the current branch to &lt;branch&gt;<code class="codeBlock">git branch -m &lt;branch&gt;</code></li>
        <li>List all remote branches.<code class="codeBlock">git branch -a</code></li>
      </ul>
    </section>
    <section id="git_checkout" class="main-section">
      <header>git checkout</header>
      <p>In addition to checking out old commits and old file revisions, git checkout is also the means to navigate
        existing branches.
        Combined with the basic Git commands, it’s a way to work on a particular line of development.</p>
      <p>The git checkout command lets you navigate between the branches created by git branch. Checking out a branch
        updates the files in the working directory to match the version stored in that branch, and it tells Git to
        record all new commits on that branch. Think of it as a way to select which line of development you’re working
        on.</p>
      <p>The git checkout command may occasionally be confused with git clone. The difference between the two commands
        is that clone works to fetch code from a remote repository, alternatively checkout works to switch between
        versions of code already on the local system.</p>
      <p>Assuming the repo you're working in contains pre-existing branches, you can switch between these branches
        using git checkout. To find out what branches are available and what the current branch name is, execute git
        branch.</p>
      <code class="codeBlock">$> git branch<br />
        master <br />
        another_branch <br />
        feature_inprogress_branch <br />
        $> git checkout feature_inprogress_branch</code>
      <p>The above example demonstrates how to view a list of available branches by executing the git branch command,
        and switch to a specified branch, in this case, the feature_inprogress_branch.</p>
    </section>
    <section id="#git_clean" class="main-section">
      <header>git clean</header>
      <p>Removes untracked files from the working directory. This is the logical counterpart to <code>git reset</code>,
        which (typically) only operates
        on tracked files.</p>
      <p>Git clean is to some extent an 'undo' command. Git clean can be considered complementary to other commands
        like git reset and git checkout. Whereas these other commands operate on files previously added to the Git
        tracking index, the git clean command operates on untracked files. Untracked files are files that have been
        created within your repo's working directory but have not yet been added to the repository's tracking index
        using the git add command.</p>
      <p>Common Options:</p>
      <ul>
        <li>Commit the staged snapshot. This will launch a text editor prompting you for a commit message. After you’ve
          entered a message, save the file and close the editor to create the actual commit.
          <code class="codeBlock">git commit</code>
        </li>
        <li>Commit a snapshot of all changes in the working directory. This only includes modifications to tracked
          files (those that have been added with git add at some point in their history).
          <code class="codeBlock">git commit -a</code>
        </li>
        <li>A shortcut command that immediately creates a commit with a passed commit message. By default, git commit
          will open up the locally configured text editor, and prompt for a commit message to be entered. Passing the
          -m option will forgo the text editor prompt in-favor of an inline message.
          <code class="codeBlock">git commit -m "commit message"</code>
        </li>
        <li>A power user shortcut command that combines the -a and -m options. This combination immediately creates a
          commit of all the staged changes and takes an inline commit message.
          <code class="codeBlock">git commit -am "commit message"</code>
        </li>
      </ul>
    </section>
    <section id="git_clone" class="main-section">
      <header>git clone</header>
      <p>Creates a copy of an existing Git repository. Cloning is the most common way for developers to obtain a
        working copy of a
        central repository.</p>
      <p>If a project has already been set up in a central repository, the clone command is the most common way for
        users to obtain a local development clone. Like git init, cloning is generally a one-time operation. Once a
        developer has obtained a working copy, all version control operations are managed through their local
        repository.</p>
      <code class="codeBlock">git clone &lt;repo url&gt;</code>
      <p>git clone is used to create a copy or clone of remote repositories. You pass git clone a repository URL. Git
        supports a few different network protocols and corresponding URL formats. </p>
    </section>
    <section id="git_commit" class="main-section">
      <header>git commit</header>
      <p>Takes the staged snapshot and commits it to the project history. Combined with <code>git add</code>, this
        defines the basic workflow
        for all Git users.</p>
      <p>The git commit command captures a snapshot of the project's currently staged changes. Committed snapshots can
        be thought of as “safe” versions of a project—Git will never change them unless you explicitly ask it to. Prior
        to the execution of git commit, The git add command is used to promote or 'stage' changes to the project that
        will be stored in a commit. These two commands git commit and git add are two of the most frequently used.</p>
    </section>
    <section id="git_commit_--amend" class="main-section">
      <header>git commit --amend</header>
      <p>Passing the --amend flag to git commit lets you amend the most recent commit. This is very useful when you
        forget
        to stage a file or omit important information from the commit message.</p>
      <p>This option adds another level of functionality to the commit command. Passing this option will modify the
        last commit. Instead of creating a new commit, staged changes will be added to the previous commit. This
        command will open up the system's configured text editor and prompt to change the previously specified commit
        message.</p>
      <code class="codeBlock">git commit --amend</code>
    </section>
    <section id="git_config" class="main-section">
      <header>git config</header>
      <p>A convenient way to set configuration options for your Git installation. You’ll typically only need to use
        this
        immediately after installing Git on a new development machine.</p>
      <p>The git config command lets you configure your Git installation (or an individual repository) from the command
        line. This command can define everything from user info, to preferences, to the behavior of a repository.</p>
      <p>Git stores configuration options in three separate files, which lets you scope options to individual
        repositories (local), user (Global), or the entire system (system):
        <code class="codeBlock">
          Local: &lt;repo&gt;/.git/config – Repository-specific settings.<br />
          Global: /.gitconfig – User-specific settings. This is where options set with the --global flag are stored.<br />
          System: $(prefix)/etc/gitconfig – System-wide settings.</code>
        Define the author name to be used for all commits in the current repository. Typically, you’ll want to use the
        --global flag to set configuration options for the current user.</p>
      <p>Common Options:</p>
      <ul>
        <li>Define the author name to be used for all commits by the current user.
          <code class="codeBlock">git config --global user.name &lt;name&gt;</code>
        </li>
        <li>Define the author email to be used for all commits by the current user.
          <code class="codeBlock">git config --local user.email &lt;email&gt;</code>
        </li>
      </ul>
    </section>
    <section id="git_fetch" class="main-section">
      <header>git fetch</header>
      <p>Fetching downloads a branch from another repository, along with all of its associated commits and files. But,
        it doesn't try to integrate anything into your local repository. This gives you a chance to inspect changes
        before merging them with your project.</p>
      <p>The git fetch command downloads commits, files, and refs from a remote repository into your local repo.
        Fetching is what you do when you want to see what everybody else has been working on. It’s similar to svn
        update in that it lets you see how the central history has progressed, but it doesn’t force you to actually
        merge the changes into your repository. Git isolates fetched content as a from existing local content, it has
        absolutely no effect on your local development work. Fetched content has to be explicitly checked out using the
        git checkout command. This makes fetching a safe way to review commits before integrating them with your local
        repository.</p>

    </section>
    <section id="git_init" class="main-section">
      <header>git init</header>
      <p>Initializes a new Git repository. If you want to place a project under revision control, this is the first
        command you need to learn.</p>
      <p>The git init command creates a new Git repository. It can be used to convert an existing, unversioned project
        to a Git repository or initialize a new, empty repository. Most other Git commands are not available outside of
        an initialized repository, so this is usually the first command you'll run in a new project.</p>
    </section>
    <section id="git_log" class="main-section">
      <header>git log</header>
      <p>Lets you explore the previous revisions of a project. It provides several formatting options for displaying
        committed snapshots.</p>
      <p>The purpose of any version control system is to record changes to your code. This gives you the power to go
        back into your project history to see who contributed what, figure out where bugs were introduced, and revert
        problematic changes. But, having all of this history available is useless if you don’t know how to navigate it.
        That’s where the git log command comes in.</p>
      <p>The advanced features of git log can be split into two categories: formatting how each commit is displayed,
        and filtering which commits are included in the output. Together, these two skills give you the power to go
        back into your project and find any information that you could possibly need.</p>

    </section>
    <section id="git_merge" class="main-section">
      <header>git merge</header>
      <p>A powerful way to integrate changes from divergent branches. After forking the project history with <code>git
          branch</code>,
        <code>git merge</code> lets you put it back together again.</p>
      <p>Merging is Git's way of putting a forked history back together again. The git merge command lets you take the
        independent lines of development created by git branch and integrate them into a single branch.</p>
      <p>Common usage:</p>
      <ul>
        <li>Merge the specified branch into the current branch. Git will determine the merge algorithm automatically
          (discussed below).
          <code class="codeBlock">git merge &lt;branch&gt;</code>
        </li>
        <li>Merge the specified branch into the current branch, but always generate a merge commit (even if it was a
          fast-forward merge). This is useful for documenting all merges that occur in your repository.
          <code class="codeBlock">git merge --no-ff &lt;branch&gt;</code>
        </li>
      </ul>
    </section>
    <section id="git_pull" class="main-section">
      <header>git pull</header>
      <p>Pulling is the automated version of <code>git fetch</code>. It downloads a branch from a remote repository,
        then immediately
        merges it into the current branch. This is the Git equivalent of svn update.</p>
      <p>The git pull command is used to fetch and download content from a remote repository and immediately update the
        local repository to match that content. Merging remote upstream changes into your local repository is a common
        task in Git-based collaboration work flows. The git pull command is actually a combination of two other
        commands, git fetch followed by git merge. In the first stage of operation git pull will execute a git fetch
        scoped to the local branch that HEAD is pointed at. Once the content is downloaded, git pull will enter a merge
        workflow. A new merge commit will be-created and HEAD updated to point at the new commit.</p>
    </section>
    <section id="git_push" class="main-section">
      <header>git push</header>
      <p>Pushing is the opposite of fetching (with a few caveats). It lets you move a local branch to another
        repository,
        which serves as a convenient way to publish contributions. This is like svn commit, but it sends a series of
        commits instead of a single changeset.</p>
      <p>The git push command is used to upload local repository content to a remote repository. Pushing is how you
        transfer commits from your local repository to a remote repo. It's the counterpart to git fetch, but whereas
        fetching imports commits to local branches, pushing exports commits to remote branches. Remote branches are
        configured using the git remote command. Pushing has the potential to overwrite changes, caution should be
        taken when pushing.</p>
    </section>
    <section id="git_rebase" class="main-section">
      <header>git rebase</header>
      <p>Rebasing lets you move branches around, which helps you avoid unnecessary merge commits. The resulting linear
        history is often much easier to understand and explore.</p>
      <p>As an alternative to merging, you can rebase the feature branch onto master branch using the following
        commands:</p>
      <code class="codeBlock">git checkout feature<br />
        git rebase master</code>
      <p>This moves the entire feature branch to begin on the tip of the master branch, effectively incorporating all
        of the new commits in master. But, instead of using a merge commit, rebasing re-writes the project history by
        creating brand new commits for each commit in the original branch.</p>
    </section>
    <section id="git_rebase_-i" class="main-section">
      <header>git rebase -i</header>
      <p>The -i flag is used to begin an interactive rebasing session. This provides all the benefits of a normal
        rebase,
        but gives you the opportunity to add, edit, or delete commits along the way.</p>
      <p>Interactive rebasing gives you the opportunity to alter commits as they are moved to the new branch. This is
        even more powerful than an automated rebase, since it offers complete control over the branch’s commit history.
        Typically, this is used to clean up a messy history before merging a feature branch into master.</p>

    </section>
    <section id="git_reflog" class="main-section">
      <header>git reflog</header>
      <p>Git keeps track of updates to the tip of branches using a mechanism called reflog. This allows you to go back
        to changesets even though they are not referenced by any branch or tag.</p>
      <p>The reflog is Git’s safety net. It records almost every change you make in your repository, regardless of
        whether you committed a snapshot or not. You can think of it as a chronological history of everything you’ve
        done in your local repo. To view the reflog, run the git reflog command. It should output something that looks
        like the following:</p>
      <code class="codeBlock">400e4b7 HEAD@{0}: checkout: moving from master to HEAD~2<br />
        0e25143 HEAD@{1}: commit (amend): Integrate some awesome feature into `master`<br />
        00f5425 HEAD@{2}: commit (merge): Merge branch ';feature';<br />
        ad8621a HEAD@{3}: commit: Finish the feature</code>
    </section>
    <section id="git_remote" class="main-section">
      <header>git remote</header>
      <p>A convenient tool for administering remote connections. Instead of passing the full URL to the fetch, pull,
        and push commands, it lets you use a more meaningful shortcut.</p>
      <p>The git remote command lets you create, view, and delete connections to other repositories. Remote connections
        are more like bookmarks rather than direct links into other repositories. Instead of providing real-time access
        to another repository, they serve as convenient names that can be used to reference a not-so-convenient URL.</p>
    </section>
    <section id="git_reset" class="main-section">
      <header>git reset</header>
      <p>Undoes changes to files in the working directory. Resetting lets you clean up or completely remove changes
        that have not been pushed to a public repository.</p>
      <p>On the commit-level, resetting is a way to move the tip of a branch to a different commit. This can be used to
        remove commits from the current branch. For example, the following command moves the hotfix branch backwards by
        two commits.</p>
      <code class="codeBlock">git checkout hotfix<br />
        git reset HEAD~2</code>
      <p>The two commits that were on the end of hotfix are now dangling, or orphaned commits. This means they will be
        deleted the next time Git performs a garbage collection. In other words, you’re saying that you want to throw
        away these commits.</p>
    </section>
    <section id="git_revert" class="main-section">
      <header>git revert</header>
      <p>Undoes a committed snapshot. When you discover a faulty commit, reverting is a safe and easy way to
        completely remove it from the code base.</p>
      <p>The git revert command can be considered an 'undo' type command, however, it is not a traditional undo
        operation. Instead of removing the commit from the project history, it figures out how to invert the changes
        introduced by the commit and appends a new commit with the resulting inverse content. This prevents Git from
        losing history, which is important for the integrity of your revision history and for reliable collaboration.</p>
    </section>
    <section id="git_status" class="main-section">
      <header>git status</header>
      <p>Displays the state of the working directory and the staged snapshot. You’ll want to run this in
        conjunction with <code>git add</code> and <code>git commit</code> to see exactly what’s being included in the
        next snapshot.</p>
      <p>The git status command displays the state of the working directory and the staging area. It lets you see which
        changes have been staged, which haven’t, and which files aren’t being tracked by Git. Status output does not
        show you any information regarding the committed project history. For this, you need to use git log.</p>
      <p>List which files are staged, unstaged, and untracked.</p>
      <code class="codeBlock">git status</code>
    </section>
    <section id="reference">
      <p>All definitions and descriptions on this page have been taken from <a href="https://www.atlassian.com/" target="_blank">www.atlassian.com</a></p>
    </section>
  </main>

</body>

</html>